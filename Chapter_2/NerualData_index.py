import numpy as np

#  NumPy 标量
x = np.array(12)
print(x)
# 12
print(x.ndim)
# 0
# 标量张量有 0 个轴（ndim == 0）。
# 张量轴的个数也叫作阶（rank）。

# 向量（1 阶张量）
x = np.array([12, 3, 6, 14, 7])
# 这个向量包含 5 个元素，所以叫作 5 维向量。
print(x)
# [12  3  6 14  7]
print(x.ndim)
# 1

# 矩阵（2 阶张量）
x = np.array([[5, 78, 2, 34, 0],
              [6, 79, 3, 35, 1],
              [7, 80, 4, 36, 2]])
print(x.ndim)
# 2

# 3 阶张量与更高阶的张量
# 将多个矩阵打包成一个新的数组，就可以得到一个 3 阶张量（或称为 3 维张量）
x = np.array([[[5, 78, 2, 34, 0],
               [6, 79, 3, 35, 1],
               [7, 80, 4, 36, 2]],
              [[5, 78, 2, 34, 0],
               [6, 79, 3, 35, 1],
               [7, 80, 4, 36, 2]],
              [[5, 78, 2, 34, 0],
               [6, 79, 3, 35, 1],
               [7, 80, 4, 36, 2]]])
print(x.ndim)
# 3


#  ·轴的个数（阶数）。张量的 ndim。

#  ·形状。这是一个整数元组，表示张量沿每个轴的维度大小（元素个数）。
# 举例来说，前面的矩阵示例的形状为 (3, 5)，3 阶张量示例的形状为 (3, 3, 5)。向量的形状只包含一个元素，比如 (5,)，而标量的形状为空，即 ()。

#  ·数据类型（在 Python 库中通常叫作 dtype）。这是张量中所包含数据的类型。
# 举例来说，张量的类型可以是 float16、float32、float64、uint8 等。在 TensorFlow 中，你还可能会遇到 string 类型的张量。


from keras.datasets import mnist

(train_images, train_labels), (test_images, test_labels) = mnist.load_data()
# 下面给出张量 train_images(训练数据图像) 的轴的个数，即 ndim 属性。
print(train_images.ndim)
# 3
# 下面给出它的形状。
print(train_images.shape)
(60000, 28, 28)
# 下面给出它的数据类型，即 dtype 属性。
print(train_images.dtype)
# uint8
# 解释：mnist训练数据由 60 000 个矩阵组成的数组，每个矩阵由 28×28 个整数组成。
# 每个这样的矩阵都是一张灰度图像，元素取值在 0 和 255 之间

# 显示第九个数字
import matplotlib.pyplot as plt

digit = train_images[4]
plt.imshow(digit, cmap=plt.cm.binary)
plt.show()
print(train_labels[4])
# 9

# 选择张量的特定元素叫作张量切片（tensor slicing）。
my_slice = train_images[10:100]
print(my_slice.shape)
# (90, 28, 28)

my_slice = train_images[10:100, :, :]
print(my_slice.shape)
# (90, 28, 28)
my_slice = train_images[10:100, 0:28, 0:28]
print(my_slice.shape)
# (90, 28, 28)

# 现实世界中的数据张量
# 1、向量数据：形状为 (samples, features) 的 2 阶张量，每个样本都是一个数值（“特征”）向量。
# 2、时间序列数据或序列数据：形状为 (samples, timesteps, features) 的 3 阶张量，每个样本都是特征向量组成的序列（序列长度为 timesteps）。
# 3、图像数据：形状为 (samples, height, width, channels) 的 4 阶张量，每个样本都是一个二维像素网格，每个像素则由一个“通道”（channel）向量表示。
# 4、视频数据：形状为 (samples, frames, height, width, channels) 的 5 阶张量，每个样本都是由图像组成的序列（序列长度为 frames）


# 1、向量数据：
# e.g1保险精算数据集。我们考虑每个人的年龄、性别和收入。
# 每个人可表示为包含 3 个值的向量，整个数据集包含 100 000 人，因此可存储在形状为 (100000, 3) 的 2 阶张量中。
# e.g2文本文档数据集。我们将每个文档表示为每个单词在其中出现的次数（字典中包含20 000 个常用单词）。
# 每个文档可被编码为包含 20 000 个值的向量（每个值对应字典中每个单词的出现次数），整个数据集包含 500 个文档，因此可存储在形状为 (500, 20000)的张量中。

# 2、时间序列数据或序列数据：
# e.g1 股票价格数据集。每一分钟，我们将股票的当前价格、前一分钟最高价格和前一分钟最低价格保存下来。
# 因此每一分钟被编码为一个 3 维向量，一个交易日被编码为一个形状为 (390, 3) 的矩阵（一个交易日有 390 分钟 a），
# 250 天的数据则保存在一个形状为(250, 390, 3) 的 3 阶张量中。在这个例子中，每个样本是一天的股票数据。
# e.g2 推文数据集。我们将每条推文编码为由 280 个字符组成的序列，每个字符又来自于包含128 个字符的字母表。
# 在这种情况下，每个字符可以被编码为大小为 128 的二进制向量（只有在该字符对应的索引位置取值为 1，其他元素都为 0）。
# 那么每条推文可以被编码为一个形状为 (280, 128) 的 2 阶张量，包含 100 万条推文的数据集则被存储在一个形状为 (1000000, 280, 128) 的张量中。
# //个人注解：也可以像是文档一样？变成每个推文是一个string的字符串从而使得是一个（1000000，280*7）//

# 3、图像数据：
# 图像通常具有 3 个维度：高度、宽度和颜色深度。图像张量都是 3 阶张量。
# 图像张量的形状有两种约定：通道在后（channels-last）的约定（这是 TensorFlow 的标准）和
# 通道在前（channels-first）的约定（使用这种约定的人越来越少）
# 通道在后的约定是将颜色深度轴放在最后：(samples, height, width, color_depth)。
# 与此相对，通道在前的约定是将颜色深度轴放在紧跟批量轴之后：(samples, color_depth, height, width)。
# 如果采用通道在前的约定，那么前面两个例子的形状将变成 (128, 1, 256, 256) 和 (128, 3, 256, 256)。
# Keras API 同时支持这两种格式。

# 4、视频数据：
# 视频可以看作帧的序列，每一帧都是一张彩色图像。由于每一帧都可以保存在一个形状为 (height, width, color_depth) 的 3 阶张量中，
# 因此一个视频（帧的序列）可以保存在一个形状为 (frames, height, width, color_depth) 的 4 阶张量中，
# 由多个视频组成的批量则可以保存在一个形状为 (samples, frames, height, width, color_depth) 的 5 阶张量中。
# e.g.1一个尺寸为 144×256 的 60 秒 YouTube 视频片段，以每秒 4 帧采样，那么这个视频共有 240 帧。
# 4 个这样的视频片段组成的批量将保存在形状为 (4, 240, 144, 256, 3)的张量中。这个张量共包含 106 168 320 个值！
# 如果张量的数据类型（dtype）是 float32，每个值都是 32 位，那么这个张量共有 405 MB。
# 好大！你在现实生活中遇到的视频要小得多，因为它们不以 float32 格式存储，而且通常被大大压缩（比如 MPEG 格式）。
